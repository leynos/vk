{"request":{"query":"\n    query($owner: String!, $name: String!, $number: Int!, $cursor: String) {\n      repository(owner: $owner, name: $name) {\n        pullRequest(number: $number) {\n          reviewThreads(first: 100, after: $cursor) {\n            nodes {\n              id\n              isResolved\n              comments(first: 100) {\n                nodes {\n                  body\n                  diffHunk\n                  originalPosition\n                  position\n                  path\n                  url\n                  author { login }\n                }\n                pageInfo { hasNextPage endCursor }\n              }\n            }\n            pageInfo { hasNextPage endCursor }\n          }\n        }\n      }\n    }\n","variables":{"cursor":null,"name":"shared-actions","number":42,"owner":"leynos"}},"response":"{\"data\":{\"repository\":{\"pullRequest\":{\"reviewThreads\":{\"nodes\":[{\"id\":\"PRRT_kwDOO9OxNc5Vvy6a\",\"isResolved\":true,\"comments\":{\"nodes\":[{\"body\":\"**suggestion (testing):** Consider adding tests for edge cases in lcov parsing, such as zero lines found or missing tags.\\n\\nCurrently, only the standard case is tested. Please add tests for scenarios like LF = 0, missing LH, or malformed lcov files to ensure robust parsing.\\n\\nSuggested implementation:\\n\\n```python\\n    out.write_text(\\\"LF:200\\\\nLH:163\\\\n\\\")\\n    shell_stubs.register(\\n        \\\"cargo\\\",\\n        stdout=\\\"Coverage: 81.5%\\\\n\\\",\\n\\n    data = gh.read_text().splitlines()\\n    assert f\\\"file={out}\\\" in data\\n    assert \\\"percent=81.50\\\" in data\\n\\n\\ndef test_lcov_zero_lines_found(tmp_path: Path, shell_stubs: StubManager) -> None:\\n    out = tmp_path / \\\"cov_zero.lcov\\\"\\n    gh = tmp_path / \\\"gh_zero.txt\\\"\\n\\n    # LF = 0, LH = 0\\n    out.write_text(\\\"LF:0\\\\nLH:0\\\\n\\\")\\n    shell_stubs.register(\\n        \\\"cargo\\\",\\n        stdout=\\\"Coverage: 0.0%\\\\n\\\",\\n    )\\n    # Simulate the rest of the test as in the main test, or call the function under test\\n    # For demonstration, we assume the same output file is written\\n    data = [\\\"file={}\\\".format(out), \\\"percent=0.00\\\"]\\n    assert f\\\"file={out}\\\" in data\\n    assert \\\"percent=0.00\\\" in data\\n\\n\\ndef test_lcov_missing_lh_tag(tmp_path: Path, shell_stubs: StubManager) -> None:\\n    out = tmp_path / \\\"cov_missing_lh.lcov\\\"\\n    gh = tmp_path / \\\"gh_missing_lh.txt\\\"\\n\\n    # Only LF present\\n    out.write_text(\\\"LF:100\\\\n\\\")\\n    shell_stubs.register(\\n        \\\"cargo\\\",\\n        stdout=\\\"Coverage: 0.0%\\\\n\\\",\\n    )\\n    # Simulate the rest of the test as in the main test, or call the function under test\\n    # For demonstration, we assume the output is handled gracefully\\n    data = [\\\"file={}\\\".format(out), \\\"percent=0.00\\\"]\\n    assert f\\\"file={out}\\\" in data\\n    assert \\\"percent=0.00\\\" in data\\n\\n\\ndef test_lcov_malformed_file(tmp_path: Path, shell_stubs: StubManager) -> None:\\n    out = tmp_path / \\\"cov_malformed.lcov\\\"\\n    gh = tmp_path / \\\"gh_malformed.txt\\\"\\n\\n    # Malformed: non-integer values and missing LF\\n    out.write_text(\\\"LF:abc\\\\nLH:xyz\\\\n\\\")\\n    shell_stubs.register(\\n        \\\"cargo\\\",\\n        stdout=\\\"Coverage: 0.0%\\\\n\\\",\\n    )\\n    # Simulate the rest of the test as in the main test, or call the function under test\\n    # For demonstration, we assume the output is handled gracefully\\n    data = [\\\"file={}\\\".format(out), \\\"percent=0.00\\\"]\\n    assert f\\\"file={out}\\\" in data\\n    assert \\\"percent=0.00\\\" in data\\n\\n```\\n\\n- If the actual lcov parsing logic is in a helper function, you may want to call that function directly in these tests and assert on its return value or raised exceptions.\\n- Adjust the test logic to match the actual output and error handling of your codebase (e.g., if errors are logged or exceptions are raised, assert accordingly).\\n- If the output file or percent calculation is handled differently, update the assertions to match the real behavior.\",\"diffHunk\":\"@@ -23,6 +23,7 @@ def test_run_rust_success(tmp_path: Path, shell_stubs: StubManager) -> None:\\n     out = tmp_path / \\\"cov.lcov\\\"\\n     gh = tmp_path / \\\"gh.txt\\\"\\n \\n+    out.write_text(\\\"LF:200\\\\nLH:163\\\\n\\\")\",\"originalPosition\":4,\"position\":58,\"path\":\".github/actions/generate-coverage/tests/test_scripts.py\",\"url\":\"https://github.com/leynos/shared-actions/pull/42#discussion_r2233596635\",\"author\":{\"login\":\"sourcery-ai\"}},{\"body\":\"Has this now been resolved?\",\"diffHunk\":\"@@ -23,6 +23,7 @@ def test_run_rust_success(tmp_path: Path, shell_stubs: StubManager) -> None:\\n     out = tmp_path / \\\"cov.lcov\\\"\\n     gh = tmp_path / \\\"gh.txt\\\"\\n \\n+    out.write_text(\\\"LF:200\\\\nLH:163\\\\n\\\")\",\"originalPosition\":4,\"position\":58,\"path\":\".github/actions/generate-coverage/tests/test_scripts.py\",\"url\":\"https://github.com/leynos/shared-actions/pull/42#discussion_r2233940140\",\"author\":{\"login\":\"leynos\"}}],\"pageInfo\":{\"hasNextPage\":false,\"endCursor\":\"Y3Vyc29yOnYyOpK0MjAyNS0wNy0yN1QxMjowNzowMFrOhSc4rA==\"}}},{\"id\":\"PRRT_kwDOO9OxNc5Vvy6c\",\"isResolved\":true,\"comments\":{\"nodes\":[{\"body\":\"**suggestion (code-quality):** We've found these issues:\\n\\n- Lift code into else after jump in control flow ([`reintroduce-else`](https://docs.sourcery.ai/Reference/Default-Rules/refactorings/reintroduce-else/))\\n- Replace if statement with if expression ([`assign-if-exp`](https://docs.sourcery.ai/Reference/Default-Rules/refactorings/assign-if-exp/))\\n\\n```suggestion\\n    return \\\"0.00\\\" if lines_found == 0 else f\\\"{lines_hit / lines_found * 100:.2f}\\\"\\n```\",\"diffHunk\":\"@@ -48,6 +48,20 @@ def extract_percent(output: str) -> str:\\n     return match[1]\\n \\n \\n+def percent_from_lcov(lcov_file: Path) -> str:\\n+    \\\"\\\"\\\"Return the overall line coverage from an ``lcov.info`` file.\\\"\\\"\\\"\\n+    text = lcov_file.read_text(encoding=\\\"utf-8\\\")\\n+\\n+    def total(tag: str) -> int:\\n+        return sum(map(int, re.findall(rf\\\"^{tag}:(\\\\d+)$\\\", text, flags=re.MULTILINE)))\\n+\\n+    lines_found = total(\\\"LF\\\")\\n+    lines_hit = total(\\\"LH\\\")\\n+    if lines_found == 0:\\n+        return \\\"0.00\\\"\\n+    return f\\\"{lines_hit / lines_found * 100:.2f}\\\"\",\"originalPosition\":15,\"position\":49,\"path\":\".github/actions/generate-coverage/scripts/run_rust.py\",\"url\":\"https://github.com/leynos/shared-actions/pull/42#discussion_r2233596637\",\"author\":{\"login\":\"sourcery-ai\"}},{\"body\":\"Has this now been resolved?\",\"diffHunk\":\"@@ -48,6 +48,20 @@ def extract_percent(output: str) -> str:\\n     return match[1]\\n \\n \\n+def percent_from_lcov(lcov_file: Path) -> str:\\n+    \\\"\\\"\\\"Return the overall line coverage from an ``lcov.info`` file.\\\"\\\"\\\"\\n+    text = lcov_file.read_text(encoding=\\\"utf-8\\\")\\n+\\n+    def total(tag: str) -> int:\\n+        return sum(map(int, re.findall(rf\\\"^{tag}:(\\\\d+)$\\\", text, flags=re.MULTILINE)))\\n+\\n+    lines_found = total(\\\"LF\\\")\\n+    lines_hit = total(\\\"LH\\\")\\n+    if lines_found == 0:\\n+        return \\\"0.00\\\"\\n+    return f\\\"{lines_hit / lines_found * 100:.2f}\\\"\",\"originalPosition\":15,\"position\":49,\"path\":\".github/actions/generate-coverage/scripts/run_rust.py\",\"url\":\"https://github.com/leynos/shared-actions/pull/42#discussion_r2233940173\",\"author\":{\"login\":\"leynos\"}},{\"body\":\"Yes, this has been resolved. The code now uses the more concise form:\\n\\n```python\\nreturn \\\"0.00\\\" if lines_found == 0 else f\\\"{lines_hit / lines_found * 100:.2f}\\\"\\n```\\n\\nThis matches the suggestion and is present in the current implementation of `percent_from_lcov`. If you have any further questions or need additional changes, let me know!\",\"diffHunk\":\"@@ -48,6 +48,20 @@ def extract_percent(output: str) -> str:\\n     return match[1]\\n \\n \\n+def percent_from_lcov(lcov_file: Path) -> str:\\n+    \\\"\\\"\\\"Return the overall line coverage from an ``lcov.info`` file.\\\"\\\"\\\"\\n+    text = lcov_file.read_text(encoding=\\\"utf-8\\\")\\n+\\n+    def total(tag: str) -> int:\\n+        return sum(map(int, re.findall(rf\\\"^{tag}:(\\\\d+)$\\\", text, flags=re.MULTILINE)))\\n+\\n+    lines_found = total(\\\"LF\\\")\\n+    lines_hit = total(\\\"LH\\\")\\n+    if lines_found == 0:\\n+        return \\\"0.00\\\"\\n+    return f\\\"{lines_hit / lines_found * 100:.2f}\\\"\",\"originalPosition\":15,\"position\":49,\"path\":\".github/actions/generate-coverage/scripts/run_rust.py\",\"url\":\"https://github.com/leynos/shared-actions/pull/42#discussion_r2233940312\",\"author\":{\"login\":\"sourcery-ai\"}}],\"pageInfo\":{\"hasNextPage\":false,\"endCursor\":\"Y3Vyc29yOnYyOpK0MjAyNS0wNy0yN1QxMjowNzozMFrOhSc5WA==\"}}},{\"id\":\"PRRT_kwDOO9OxNc5Vvy8i\",\"isResolved\":true,\"comments\":{\"nodes\":[{\"body\":\"_🧹 Nitpick (assertive)_\\n\\n**Approve the LCOV parsing implementation with minor suggestions.**\\n\\nThe function correctly implements LCOV format parsing and handles the zero-division edge case appropriately. The regex pattern `^{tag}:(\\\\d+)$` with multiline flag properly matches LCOV format entries.\\n\\nConsider adding docstring parameter documentation and improve the function name for clarity:\\n\\n```diff\\n-def percent_from_lcov(lcov_file: Path) -> str:\\n-    \\\"\\\"\\\"Return the overall line coverage from an ``lcov.info`` file.\\\"\\\"\\\"\\n+def calculate_line_coverage_from_lcov(lcov_file: Path) -> str:\\n+    \\\"\\\"\\\"Return the overall line coverage percentage from an ``lcov.info`` file.\\n+    \\n+    Args:\\n+        lcov_file: Path to the LCOV format coverage file\\n+        \\n+    Returns:\\n+        Coverage percentage formatted to 2 decimal places\\n+    \\\"\\\"\\\"\\n```\\n\\n<!-- suggestion_start -->\\n\\n<details>\\n<summary>📝 Committable suggestion</summary>\\n\\n> ‼️ **IMPORTANT**\\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\\n\\n```suggestion\\ndef calculate_line_coverage_from_lcov(lcov_file: Path) -> str:\\n    \\\"\\\"\\\"Return the overall line coverage percentage from an ``lcov.info`` file.\\n    \\n    Args:\\n        lcov_file: Path to the LCOV format coverage file\\n        \\n    Returns:\\n        Coverage percentage formatted to 2 decimal places\\n    \\\"\\\"\\\"\\n    text = lcov_file.read_text(encoding=\\\"utf-8\\\")\\n\\n    def total(tag: str) -> int:\\n        return sum(map(int, re.findall(rf\\\"^{tag}:(\\\\d+)$\\\", text, flags=re.MULTILINE)))\\n\\n    lines_found = total(\\\"LF\\\")\\n    lines_hit = total(\\\"LH\\\")\\n    if lines_found == 0:\\n        return \\\"0.00\\\"\\n    return f\\\"{lines_hit / lines_found * 100:.2f}\\\"\\n```\\n\\n</details>\\n\\n<!-- suggestion_end -->\\n\\n<details>\\n<summary>🤖 Prompt for AI Agents</summary>\\n\\n```\\nIn .github/actions/generate-coverage/scripts/run_rust.py around lines 51 to 62,\\nthe function percent_from_lcov correctly parses LCOV coverage data but lacks\\nparameter documentation and could have a clearer name. Add a docstring section\\ndescribing the lcov_file parameter and rename the function to something more\\ndescriptive like get_line_coverage_percent_from_lcov to improve clarity.\\n```\\n\\n</details>\\n\\n<!-- fingerprinting:phantom:poseidon:panther -->\\n\\n<!-- This is an auto-generated comment by CodeRabbit -->\\n\\n✅ Addressed in commit f81fcbc\",\"diffHunk\":\"@@ -48,6 +48,20 @@ def extract_percent(output: str) -> str:\\n     return match[1]\\n \\n \\n+def percent_from_lcov(lcov_file: Path) -> str:\\n+    \\\"\\\"\\\"Return the overall line coverage from an ``lcov.info`` file.\\\"\\\"\\\"\\n+    text = lcov_file.read_text(encoding=\\\"utf-8\\\")\\n+\\n+    def total(tag: str) -> int:\\n+        return sum(map(int, re.findall(rf\\\"^{tag}:(\\\\d+)$\\\", text, flags=re.MULTILINE)))\\n+\\n+    lines_found = total(\\\"LF\\\")\\n+    lines_hit = total(\\\"LH\\\")\\n+    if lines_found == 0:\\n+        return \\\"0.00\\\"\\n+    return f\\\"{lines_hit / lines_found * 100:.2f}\\\"\",\"originalPosition\":15,\"position\":null,\"path\":\".github/actions/generate-coverage/scripts/run_rust.py\",\"url\":\"https://github.com/leynos/shared-actions/pull/42#discussion_r2233596801\",\"author\":{\"login\":\"coderabbitai\"}}],\"pageInfo\":{\"hasNextPage\":false,\"endCursor\":\"Y3Vyc29yOnYyOpK0MjAyNS0wNy0yN1QwMjoxNDoxOVrOhSH7gQ==\"}}},{\"id\":\"PRRT_kwDOO9OxNc5VwrcM\",\"isResolved\":true,\"comments\":{\"nodes\":[{\"body\":\"_🧹 Nitpick (assertive)_\\n\\n**Approve the LCOV parsing implementation with robust error handling.**\\n\\nThe function correctly implements LCOV format parsing and handles the zero-division edge case appropriately. The regex pattern and formatting are well-implemented.\\n\\nAdd error handling for file reading failures and malformed content to make the function more robust:\\n\\n```diff\\n def get_line_coverage_percent_from_lcov(lcov_file: Path) -> str:\\n     \\\"\\\"\\\"Return the overall line coverage percentage from an ``lcov.info`` file.\\n\\n     Parameters\\n     ----------\\n     lcov_file : Path\\n         Path to the coverage file to read.\\n\\n     Returns\\n     -------\\n     str\\n         The coverage percentage with two decimal places.\\n     \\\"\\\"\\\"\\n-    text = lcov_file.read_text(encoding=\\\"utf-8\\\")\\n+    try:\\n+        text = lcov_file.read_text(encoding=\\\"utf-8\\\")\\n+    except (FileNotFoundError, PermissionError, UnicodeDecodeError) as exc:\\n+        typer.echo(f\\\"Could not read LCOV file {lcov_file}: {exc}\\\", err=True)\\n+        raise typer.Exit(code=1) from exc\\n\\n     def total(tag: str) -> int:\\n-        return sum(map(int, re.findall(rf\\\"^{tag}:(\\\\d+)$\\\", text, flags=re.MULTILINE)))\\n+        try:\\n+            return sum(map(int, re.findall(rf\\\"^{tag}:(\\\\d+)$\\\", text, flags=re.MULTILINE)))\\n+        except ValueError as exc:\\n+            typer.echo(f\\\"Malformed LCOV file {lcov_file}: invalid {tag} values\\\", err=True)\\n+            raise typer.Exit(code=1) from exc\\n\\n     lines_found = total(\\\"LF\\\")\\n     lines_hit = total(\\\"LH\\\")\\n     if lines_found == 0:\\n         return \\\"0.00\\\"\\n     return f\\\"{lines_hit / lines_found * 100:.2f}\\\"\\n```\\n\\n<!-- suggestion_start -->\\n\\n<details>\\n<summary>📝 Committable suggestion</summary>\\n\\n> ‼️ **IMPORTANT**\\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\\n\\n```suggestion\\ndef get_line_coverage_percent_from_lcov(lcov_file: Path) -> str:\\n    \\\"\\\"\\\"Return the overall line coverage percentage from an ``lcov.info`` file.\\n\\n    Parameters\\n    ----------\\n    lcov_file : Path\\n        Path to the coverage file to read.\\n\\n    Returns\\n    -------\\n    str\\n        The coverage percentage with two decimal places.\\n    \\\"\\\"\\\"\\n    try:\\n        text = lcov_file.read_text(encoding=\\\"utf-8\\\")\\n    except (FileNotFoundError, PermissionError, UnicodeDecodeError) as exc:\\n        typer.echo(f\\\"Could not read LCOV file {lcov_file}: {exc}\\\", err=True)\\n        raise typer.Exit(code=1) from exc\\n\\n    def total(tag: str) -> int:\\n        try:\\n            return sum(map(int, re.findall(rf\\\"^{tag}:(\\\\d+)$\\\", text, flags=re.MULTILINE)))\\n        except ValueError as exc:\\n            typer.echo(f\\\"Malformed LCOV file {lcov_file}: invalid {tag} values\\\", err=True)\\n            raise typer.Exit(code=1) from exc\\n\\n    lines_found = total(\\\"LF\\\")\\n    lines_hit = total(\\\"LH\\\")\\n    if lines_found == 0:\\n        return \\\"0.00\\\"\\n    return f\\\"{lines_hit / lines_found * 100:.2f}\\\"\\n```\\n\\n</details>\\n\\n<!-- suggestion_end -->\\n\\n<details>\\n<summary>🤖 Prompt for AI Agents</summary>\\n\\n```\\nIn .github/actions/generate-coverage/scripts/run_rust.py around lines 51 to 73,\\nthe function get_line_coverage_percent_from_lcov lacks error handling for file\\nreading failures and malformed content. Add a try-except block around the file\\nreading operation to catch and handle exceptions like FileNotFoundError or\\nIOError. Also, validate the regex parsing results to ensure they contain valid\\nintegers before summing, and handle any ValueError that may arise during\\nconversion. Return a default coverage value or raise a clear error if parsing\\nfails.\\n```\\n\\n</details>\\n\\n<!-- fingerprinting:phantom:poseidon:panther -->\\n\\n<!-- This is an auto-generated comment by CodeRabbit -->\\n\\n✅ Addressed in commit 2925525\",\"diffHunk\":\"@@ -48,6 +48,31 @@ def extract_percent(output: str) -> str:\\n     return match[1]\\n \\n \\n+def get_line_coverage_percent_from_lcov(lcov_file: Path) -> str:\\n+    \\\"\\\"\\\"Return the overall line coverage percentage from an ``lcov.info`` file.\\n+\\n+    Parameters\\n+    ----------\\n+    lcov_file : Path\\n+        Path to the coverage file to read.\\n+\\n+    Returns\\n+    -------\\n+    str\\n+        The coverage percentage with two decimal places.\\n+    \\\"\\\"\\\"\\n+    text = lcov_file.read_text(encoding=\\\"utf-8\\\")\\n+\\n+    def total(tag: str) -> int:\\n+        return sum(map(int, re.findall(rf\\\"^{tag}:(\\\\d+)$\\\", text, flags=re.MULTILINE)))\\n+\\n+    lines_found = total(\\\"LF\\\")\\n+    lines_hit = total(\\\"LH\\\")\\n+    if lines_found == 0:\\n+        return \\\"0.00\\\"\\n+    return f\\\"{lines_hit / lines_found * 100:.2f}\\\"\",\"originalPosition\":26,\"position\":null,\"path\":\".github/actions/generate-coverage/scripts/run_rust.py\",\"url\":\"https://github.com/leynos/shared-actions/pull/42#discussion_r2233947249\",\"author\":{\"login\":\"coderabbitai\"}}],\"pageInfo\":{\"hasNextPage\":false,\"endCursor\":\"Y3Vyc29yOnYyOpK0MjAyNS0wNy0yN1QxMjoxNTo1MlrOhSdUcQ==\"}}},{\"id\":\"PRRT_kwDOO9OxNc5Vwvc3\",\"isResolved\":false,\"comments\":{\"nodes\":[{\"body\":\"_🧹 Nitpick (assertive)_\\n\\n_🛠️ Refactor suggestion_\\n\\n**Extract duplicated XML parsing logic to a shared module.**\\n\\nThe `get_line_coverage_percent_from_cobertura` function is duplicated between `run_rust.py` and `run_python.py`. Extract this common functionality to avoid maintenance issues.\\n\\n\\n\\n\\nCreate a new shared module `.github/actions/generate-coverage/scripts/coverage_parsers.py`:\\n\\n```python\\n\\\"\\\"\\\"Common coverage file parsers.\\\"\\\"\\\"\\n\\nfrom decimal import ROUND_HALF_UP, Decimal\\nfrom pathlib import Path\\n\\nimport typer\\n\\n\\ndef get_line_coverage_percent_from_cobertura(xml_file: Path) -> str:\\n    \\\"\\\"\\\"Return the overall line coverage percentage from a Cobertura XML file.\\n\\n    Parameters\\n    ----------\\n    xml_file : Path\\n        Path to the coverage file to read.\\n\\n    Returns\\n    -------\\n    str\\n        The coverage percentage with two decimal places.\\n    \\\"\\\"\\\"\\n    try:\\n        from lxml import etree\\n    except ImportError as exc:\\n        typer.echo(\\\"lxml is required for XML parsing. Please install it.\\\", err=True)\\n        raise typer.Exit(code=1) from exc\\n\\n    try:\\n        root = etree.parse(str(xml_file)).getroot()\\n    except (FileNotFoundError, PermissionError, etree.XMLSyntaxError) as exc:\\n        typer.echo(f\\\"Could not parse XML file {xml_file}: {exc}\\\", err=True)\\n        raise typer.Exit(code=1) from exc\\n\\n    def num_or_zero(expr: str) -> int:\\n        n = root.xpath(f\\\"number({expr})\\\")\\n        return 0 if n != n else int(n)\\n\\n    def lines_from_detail() -> tuple[int, int]:\\n        total = int(root.xpath(\\\"count(//class/lines/line)\\\"))\\n        covered = int(root.xpath(\\\"count(//class/lines/line[number(@hits) > 0])\\\"))\\n        return covered, total\\n\\n    covered, total = lines_from_detail()\\n    if total == 0:\\n        covered = num_or_zero(\\\"/coverage/@lines-covered\\\")\\n        total = num_or_zero(\\\"/coverage/@lines-valid\\\")\\n\\n    if total == 0:\\n        return \\\"0.00\\\"\\n\\n    percent = (\\n        Decimal(covered) / Decimal(total) * 100\\n    ).quantize(Decimal(\\\"0.01\\\"), rounding=ROUND_HALF_UP)\\n    return f\\\"{percent}\\\"\\n```\\n\\nThen import and use it in both scripts:\\n\\n```diff\\n-def get_line_coverage_percent_from_cobertura(xml_file: Path) -> str:\\n-    # ... entire function ...\\n+from coverage_parsers import get_line_coverage_percent_from_cobertura\\n```\\n\\n\\nAlso applies to: 46-85\\n\\n<details>\\n<summary>🤖 Prompt for AI Agents</summary>\\n\\n```\\nIn .github/actions/generate-coverage/scripts/run_python.py around lines 4 and 46\\nto 85, the function get_line_coverage_percent_from_cobertura is duplicated from\\nrun_rust.py. To fix this, create a new shared module at\\n.github/actions/generate-coverage/scripts/coverage_parsers.py containing the\\nfull implementation of get_line_coverage_percent_from_cobertura as described.\\nThen, remove the duplicated function from both run_python.py and run_rust.py,\\nand import get_line_coverage_percent_from_cobertura from coverage_parsers.py in\\nboth scripts to use the shared function instead.\\n```\\n\\n</details>\\n\\n<!-- fingerprinting:phantom:medusa:lion -->\\n\\n<!-- This is an auto-generated comment by CodeRabbit -->\",\"diffHunk\":\"@@ -1,7 +1,7 @@\\n #!/usr/bin/env -S uv run --script\\n # /// script\\n # requires-python = \\\">=3.12\\\"\\n-# dependencies = [\\\"plumbum\\\", \\\"typer\\\", \\\"defusedxml\\\"]\\n+# dependencies = [\\\"plumbum\\\", \\\"typer\\\", \\\"lxml\\\"]\",\"originalPosition\":5,\"position\":5,\"path\":\".github/actions/generate-coverage/scripts/run_python.py\",\"url\":\"https://github.com/leynos/shared-actions/pull/42#discussion_r2233970408\",\"author\":{\"login\":\"coderabbitai\"}}],\"pageInfo\":{\"hasNextPage\":false,\"endCursor\":\"Y3Vyc29yOnYyOpK0MjAyNS0wNy0yN1QxMjo1MzoxN1rOhSeu6A==\"}}},{\"id\":\"PRRT_kwDOO9OxNc5Vwvc4\",\"isResolved\":false,\"comments\":{\"nodes\":[{\"body\":\"_⚠️ Potential issue_\\n\\n**Add error handling for XML parsing failures.**\\n\\nThe function should handle potential XML parsing errors and file reading failures gracefully.\\n\\n\\n\\n```diff\\n def get_line_coverage_percent_from_cobertura(xml_file: Path) -> str:\\n     \\\"\\\"\\\"Return the overall line coverage percentage from a Cobertura XML file.\\n\\n     Parameters\\n     ----------\\n     xml_file : Path\\n         Path to the coverage file to read.\\n\\n     Returns\\n     -------\\n     str\\n         The coverage percentage with two decimal places.\\n     \\\"\\\"\\\"\\n     from decimal import ROUND_HALF_UP, Decimal\\n\\n-    from lxml import etree\\n+    try:\\n+        from lxml import etree\\n+    except ImportError as exc:\\n+        typer.echo(\\\"lxml is required for XML parsing. Please install it.\\\", err=True)\\n+        raise typer.Exit(code=1) from exc\\n\\n-    root = etree.parse(str(xml_file)).getroot()\\n+    try:\\n+        root = etree.parse(str(xml_file)).getroot()\\n+    except (FileNotFoundError, PermissionError, etree.XMLSyntaxError) as exc:\\n+        typer.echo(f\\\"Could not parse XML file {xml_file}: {exc}\\\", err=True)\\n+        raise typer.Exit(code=1) from exc\\n\\n     def num_or_zero(expr: str) -> int:\\n         n = root.xpath(f\\\"number({expr})\\\")\\n         return 0 if n != n else int(n)\\n\\n     def lines_from_detail() -> tuple[int, int]:\\n         total = int(root.xpath(\\\"count(//class/lines/line)\\\"))\\n         covered = int(root.xpath(\\\"count(//class/lines/line[number(@hits) > 0])\\\"))\\n         return covered, total\\n\\n     covered, total = lines_from_detail()\\n     if total == 0:\\n         covered = num_or_zero(\\\"/coverage/@lines-covered\\\")\\n         total = num_or_zero(\\\"/coverage/@lines-valid\\\")\\n\\n     if total == 0:\\n         return \\\"0.00\\\"\\n\\n     percent = (\\n         Decimal(covered) / Decimal(total) * 100\\n     ).quantize(Decimal(\\\"0.01\\\"), rounding=ROUND_HALF_UP)\\n     return f\\\"{percent}\\\"\\n```\\n\\n<!-- suggestion_start -->\\n\\n<details>\\n<summary>📝 Committable suggestion</summary>\\n\\n> ‼️ **IMPORTANT**\\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\\n\\n```suggestion\\ndef get_line_coverage_percent_from_cobertura(xml_file: Path) -> str:\\n    \\\"\\\"\\\"Return the overall line coverage percentage from a Cobertura XML file.\\n\\n    Parameters\\n    ----------\\n    xml_file : Path\\n        Path to the coverage file to read.\\n\\n    Returns\\n    -------\\n    str\\n        The coverage percentage with two decimal places.\\n    \\\"\\\"\\\"\\n    from decimal import ROUND_HALF_UP, Decimal\\n\\n    try:\\n        from lxml import etree\\n    except ImportError as exc:\\n        typer.echo(\\\"lxml is required for XML parsing. Please install it.\\\", err=True)\\n        raise typer.Exit(code=1) from exc\\n\\n    try:\\n        root = etree.parse(str(xml_file)).getroot()\\n    except (FileNotFoundError, PermissionError, etree.XMLSyntaxError) as exc:\\n        typer.echo(f\\\"Could not parse XML file {xml_file}: {exc}\\\", err=True)\\n        raise typer.Exit(code=1) from exc\\n\\n    def num_or_zero(expr: str) -> int:\\n        n = root.xpath(f\\\"number({expr})\\\")\\n        return 0 if n != n else int(n)\\n\\n    def lines_from_detail() -> tuple[int, int]:\\n        total = int(root.xpath(\\\"count(//class/lines/line)\\\"))\\n        covered = int(root.xpath(\\\"count(//class/lines/line[number(@hits) > 0])\\\"))\\n        return covered, total\\n\\n    covered, total = lines_from_detail()\\n    if total == 0:\\n        covered = num_or_zero(\\\"/coverage/@lines-covered\\\")\\n        total = num_or_zero(\\\"/coverage/@lines-valid\\\")\\n\\n    if total == 0:\\n        return \\\"0.00\\\"\\n\\n    percent = (\\n        Decimal(covered) / Decimal(total) * 100\\n    ).quantize(Decimal(\\\"0.01\\\"), rounding=ROUND_HALF_UP)\\n    return f\\\"{percent}\\\"\\n```\\n\\n</details>\\n\\n<!-- suggestion_end -->\\n\\n<details>\\n<summary>🤖 Prompt for AI Agents</summary>\\n\\n```\\nIn .github/actions/generate-coverage/scripts/run_rust.py around lines 76 to 116,\\nthe function get_line_coverage_percent_from_cobertura lacks error handling for\\nXML parsing and file reading issues. Wrap the XML parsing code in a try-except\\nblock to catch exceptions like file not found or XML syntax errors, and handle\\nthem gracefully by returning a default coverage value or logging an appropriate\\nerror message.\\n```\\n\\n</details>\\n\\n<!-- fingerprinting:phantom:medusa:lion -->\\n\\n<!-- This is an auto-generated comment by CodeRabbit -->\",\"diffHunk\":\"@@ -48,6 +48,73 @@ def extract_percent(output: str) -> str:\\n     return match[1]\\n \\n \\n+def get_line_coverage_percent_from_lcov(lcov_file: Path) -> str:\\n+    \\\"\\\"\\\"Return the overall line coverage percentage from an ``lcov.info`` file.\\n+\\n+    Parameters\\n+    ----------\\n+    lcov_file : Path\\n+        Path to the coverage file to read.\\n+\\n+    Returns\\n+    -------\\n+    str\\n+        The coverage percentage with two decimal places.\\n+    \\\"\\\"\\\"\\n+    text = lcov_file.read_text(encoding=\\\"utf-8\\\")\\n+\\n+    def total(tag: str) -> int:\\n+        return sum(map(int, re.findall(rf\\\"^{tag}:(\\\\d+)$\\\", text, flags=re.MULTILINE)))\\n+\\n+    lines_found = total(\\\"LF\\\")\\n+    lines_hit = total(\\\"LH\\\")\\n+    if lines_found == 0:\\n+        return \\\"0.00\\\"\\n+    return f\\\"{lines_hit / lines_found * 100:.2f}\\\"\\n+\\n+\\n+def get_line_coverage_percent_from_cobertura(xml_file: Path) -> str:\\n+    \\\"\\\"\\\"Return the overall line coverage percentage from a Cobertura XML file.\\n+\\n+    Parameters\\n+    ----------\\n+    xml_file : Path\\n+        Path to the coverage file to read.\\n+\\n+    Returns\\n+    -------\\n+    str\\n+        The coverage percentage with two decimal places.\\n+    \\\"\\\"\\\"\\n+    from decimal import ROUND_HALF_UP, Decimal\\n+\\n+    from lxml import etree\\n+\\n+    root = etree.parse(str(xml_file)).getroot()\\n+\\n+    def num_or_zero(expr: str) -> int:\\n+        n = root.xpath(f\\\"number({expr})\\\")\\n+        return 0 if n != n else int(n)\\n+\\n+    def lines_from_detail() -> tuple[int, int]:\\n+        total = int(root.xpath(\\\"count(//class/lines/line)\\\"))\\n+        covered = int(root.xpath(\\\"count(//class/lines/line[number(@hits) > 0])\\\"))\\n+        return covered, total\\n+\\n+    covered, total = lines_from_detail()\\n+    if total == 0:\\n+        covered = num_or_zero(\\\"/coverage/@lines-covered\\\")\\n+        total = num_or_zero(\\\"/coverage/@lines-valid\\\")\\n+\\n+    if total == 0:\\n+        return \\\"0.00\\\"\\n+\\n+    percent = (\\n+        Decimal(covered) / Decimal(total) * 100\\n+    ).quantize(Decimal(\\\"0.01\\\"), rounding=ROUND_HALF_UP)\\n+    return f\\\"{percent}\\\"\\n+\",\"originalPosition\":78,\"position\":null,\"path\":\".github/actions/generate-coverage/scripts/run_rust.py\",\"url\":\"https://github.com/leynos/shared-actions/pull/42#discussion_r2233970410\",\"author\":{\"login\":\"coderabbitai\"}}],\"pageInfo\":{\"hasNextPage\":false,\"endCursor\":\"Y3Vyc29yOnYyOpK0MjAyNS0wNy0yN1QxMjo1MzoxN1rOhSeu6g==\"}}},{\"id\":\"PRRT_kwDOO9OxNc5Vwvc6\",\"isResolved\":false,\"comments\":{\"nodes\":[{\"body\":\"_🧹 Nitpick (assertive)_\\n\\n**Add tests for file reading error scenarios.**\\n\\nWhile the edge case tests are good, add tests to verify proper error handling for file reading failures (FileNotFoundError, PermissionError).\\n\\n\\n\\n```python\\ndef test_lcov_file_not_found(run_rust_module: types.ModuleType) -> None:\\n    \\\"\\\"\\\"``get_line_coverage_percent_from_lcov`` handles missing files gracefully.\\\"\\\"\\\"\\n    lcov = Path(\\\"/nonexistent/file.lcov\\\")\\n    with pytest.raises(SystemExit) as exc_info:\\n        run_rust_module.get_line_coverage_percent_from_lcov(lcov)\\n    assert exc_info.value.code == 1\\n```\\n\\n<details>\\n<summary>🤖 Prompt for AI Agents</summary>\\n\\n```\\nIn .github/actions/generate-coverage/tests/test_scripts.py around lines 160 to\\n181, add new test functions to cover file reading error scenarios such as\\nFileNotFoundError and PermissionError. Create tests that attempt to read\\nnon-existent or inaccessible files and assert that the function\\nget_line_coverage_percent_from_lcov properly handles these errors by raising\\nSystemExit with code 1. This ensures robust error handling for file I/O issues.\\n```\\n\\n</details>\\n\\n<!-- fingerprinting:phantom:medusa:lion -->\\n\\n<!-- This is an auto-generated comment by CodeRabbit -->\",\"diffHunk\":\"@@ -116,3 +155,106 @@ def test_merge_cobertura(tmp_path: Path, shell_stubs: StubManager) -> None:\\n     calls = shell_stubs.calls_of(\\\"uvx\\\")\\n     assert calls\\n     assert calls[0].argv[:1] == [\\\"merge-cobertura\\\"]\\n+\\n+\\n+def test_lcov_zero_lines_found(\\n+    tmp_path: Path, run_rust_module: types.ModuleType\\n+) -> None:\\n+    \\\"\\\"\\\"``get_line_coverage_percent_from_lcov`` returns 0.00 when no lines are found.\\\"\\\"\\\"\\n+    lcov = tmp_path / \\\"zero.lcov\\\"\\n+    lcov.write_text(\\\"LF:0\\\\nLH:0\\\\n\\\")\\n+    assert run_rust_module.get_line_coverage_percent_from_lcov(lcov) == \\\"0.00\\\"\\n+\\n+\\n+def test_lcov_missing_lh_tag(tmp_path: Path, run_rust_module: types.ModuleType) -> None:\\n+    \\\"\\\"\\\"``get_line_coverage_percent_from_lcov`` handles files missing ``LH`` tags.\\\"\\\"\\\"\\n+    lcov = tmp_path / \\\"missing.lcov\\\"\\n+    lcov.write_text(\\\"LF:100\\\\n\\\")\\n+    assert run_rust_module.get_line_coverage_percent_from_lcov(lcov) == \\\"0.00\\\"\\n+\\n+\\n+def test_lcov_malformed_file(tmp_path: Path, run_rust_module: types.ModuleType) -> None:\\n+    \\\"\\\"\\\"``get_line_coverage_percent_from_lcov`` returns 0.00 for malformed files.\\\"\\\"\\\"\\n+    lcov = tmp_path / \\\"bad.lcov\\\"\\n+    lcov.write_text(\\\"LF:abc\\\\nLH:xyz\\\\n\\\")\\n+    assert run_rust_module.get_line_coverage_percent_from_lcov(lcov) == \\\"0.00\\\"\\n+\",\"originalPosition\":98,\"position\":98,\"path\":\".github/actions/generate-coverage/tests/test_scripts.py\",\"url\":\"https://github.com/leynos/shared-actions/pull/42#discussion_r2233970412\",\"author\":{\"login\":\"coderabbitai\"}}],\"pageInfo\":{\"hasNextPage\":false,\"endCursor\":\"Y3Vyc29yOnYyOpK0MjAyNS0wNy0yN1QxMjo1MzoxOFrOhSeu7A==\"}}}],\"pageInfo\":{\"hasNextPage\":false,\"endCursor\":\"Y3Vyc29yOnYyOpK0MjAyNS0wNy0yN1QxMjo1MzoxOFrOVcL3Og==\"}}}}}}"}
{"request":{"query":"\n    query($owner: String!, $name: String!, $number: Int!, $cursor: String) {\n      repository(owner: $owner, name: $name) {\n        pullRequest(number: $number) {\n          reviews(first: 100, after: $cursor) {\n            nodes {\n              body\n              state\n              submittedAt\n              author { login }\n            }\n            pageInfo { hasNextPage endCursor }\n          }\n        }\n      }\n    }\n","variables":{"cursor":null,"name":"shared-actions","number":42,"owner":"leynos"}},"response":"{\"data\":{\"repository\":{\"pullRequest\":{\"reviews\":{\"nodes\":[{\"body\":\"Hey @leynos - I've reviewed your changes and found some issues that need to be addressed.\\n\\n<details>\\n<summary>Prompt for AI Agents</summary>\\n\\n~~~markdown\\nPlease address the comments from this code review:\\n## Individual Comments\\n\\n### Comment 1\\n<location> `.github/actions/generate-coverage/tests/test_scripts.py:26` </location>\\n<code_context>\\n     out = tmp_path / \\\"cov.lcov\\\"\\n     gh = tmp_path / \\\"gh.txt\\\"\\n\\n+    out.write_text(\\\"LF:200\\\\nLH:163\\\\n\\\")\\n     shell_stubs.register(\\n         \\\"cargo\\\",\\n</code_context>\\n\\n<issue_to_address>\\nConsider adding tests for edge cases in lcov parsing, such as zero lines found or missing tags.\\n\\nCurrently, only the standard case is tested. Please add tests for scenarios like LF = 0, missing LH, or malformed lcov files to ensure robust parsing.\\n\\nSuggested implementation:\\n\\n```python\\n    out.write_text(\\\"LF:200\\\\nLH:163\\\\n\\\")\\n    shell_stubs.register(\\n        \\\"cargo\\\",\\n        stdout=\\\"Coverage: 81.5%\\\\n\\\",\\n\\n    data = gh.read_text().splitlines()\\n    assert f\\\"file={out}\\\" in data\\n    assert \\\"percent=81.50\\\" in data\\n\\n\\ndef test_lcov_zero_lines_found(tmp_path: Path, shell_stubs: StubManager) -> None:\\n    out = tmp_path / \\\"cov_zero.lcov\\\"\\n    gh = tmp_path / \\\"gh_zero.txt\\\"\\n\\n    # LF = 0, LH = 0\\n    out.write_text(\\\"LF:0\\\\nLH:0\\\\n\\\")\\n    shell_stubs.register(\\n        \\\"cargo\\\",\\n        stdout=\\\"Coverage: 0.0%\\\\n\\\",\\n    )\\n    # Simulate the rest of the test as in the main test, or call the function under test\\n    # For demonstration, we assume the same output file is written\\n    data = [\\\"file={}\\\".format(out), \\\"percent=0.00\\\"]\\n    assert f\\\"file={out}\\\" in data\\n    assert \\\"percent=0.00\\\" in data\\n\\n\\ndef test_lcov_missing_lh_tag(tmp_path: Path, shell_stubs: StubManager) -> None:\\n    out = tmp_path / \\\"cov_missing_lh.lcov\\\"\\n    gh = tmp_path / \\\"gh_missing_lh.txt\\\"\\n\\n    # Only LF present\\n    out.write_text(\\\"LF:100\\\\n\\\")\\n    shell_stubs.register(\\n        \\\"cargo\\\",\\n        stdout=\\\"Coverage: 0.0%\\\\n\\\",\\n    )\\n    # Simulate the rest of the test as in the main test, or call the function under test\\n    # For demonstration, we assume the output is handled gracefully\\n    data = [\\\"file={}\\\".format(out), \\\"percent=0.00\\\"]\\n    assert f\\\"file={out}\\\" in data\\n    assert \\\"percent=0.00\\\" in data\\n\\n\\ndef test_lcov_malformed_file(tmp_path: Path, shell_stubs: StubManager) -> None:\\n    out = tmp_path / \\\"cov_malformed.lcov\\\"\\n    gh = tmp_path / \\\"gh_malformed.txt\\\"\\n\\n    # Malformed: non-integer values and missing LF\\n    out.write_text(\\\"LF:abc\\\\nLH:xyz\\\\n\\\")\\n    shell_stubs.register(\\n        \\\"cargo\\\",\\n        stdout=\\\"Coverage: 0.0%\\\\n\\\",\\n    )\\n    # Simulate the rest of the test as in the main test, or call the function under test\\n    # For demonstration, we assume the output is handled gracefully\\n    data = [\\\"file={}\\\".format(out), \\\"percent=0.00\\\"]\\n    assert f\\\"file={out}\\\" in data\\n    assert \\\"percent=0.00\\\" in data\\n\\n```\\n\\n- If the actual lcov parsing logic is in a helper function, you may want to call that function directly in these tests and assert on its return value or raised exceptions.\\n- Adjust the test logic to match the actual output and error handling of your codebase (e.g., if errors are logged or exceptions are raised, assert accordingly).\\n- If the output file or percent calculation is handled differently, update the assertions to match the real behavior.\\n</issue_to_address>\\n~~~\\n\\n</details>\\n\\n***\\n\\n<details>\\n<summary>Sourcery is free for open source - if you like our reviews please consider sharing them ✨</summary>\\n\\n- [X](https://twitter.com/intent/tweet?text=I%20just%20got%20an%20instant%20code%20review%20from%20%40SourceryAI%2C%20and%20it%20was%20brilliant%21%20It%27s%20free%20for%20open%20source%20and%20has%20a%20free%20trial%20for%20private%20code.%20Check%20it%20out%20https%3A//sourcery.ai)\\n- [Mastodon](https://mastodon.social/share?text=I%20just%20got%20an%20instant%20code%20review%20from%20%40SourceryAI%2C%20and%20it%20was%20brilliant%21%20It%27s%20free%20for%20open%20source%20and%20has%20a%20free%20trial%20for%20private%20code.%20Check%20it%20out%20https%3A//sourcery.ai)\\n- [LinkedIn](https://www.linkedin.com/sharing/share-offsite/?url=https://sourcery.ai)\\n- [Facebook](https://www.facebook.com/sharer/sharer.php?u=https://sourcery.ai)\\n\\n</details>\\n\\n<sub>\\nHelp me be more useful! Please click 👍 or 👎 on each comment and I'll use the feedback to improve your reviews.\\n</sub>\",\"state\":\"COMMENTED\",\"submittedAt\":\"2025-07-27T02:13:17Z\",\"author\":{\"login\":\"sourcery-ai\"}},{\"body\":\"**Actionable comments posted: 1**\\n\\n<details>\\n<summary>📜 Review details</summary>\\n\\n**Configuration used: CodeRabbit UI**\\n**Review profile: ASSERTIVE**\\n**Plan: Pro**\\n\\n\\n<details>\\n<summary>📥 Commits</summary>\\n\\nReviewing files that changed from the base of the PR and between 68ffa5e9f12b011ba7c9b252d76f0cebd55dbaf0 and 7bc7991ed3e05f9926706ca43f391aee3d34b4f6.\\n\\n</details>\\n\\n<details>\\n<summary>📒 Files selected for processing (2)</summary>\\n\\n* `.github/actions/generate-coverage/scripts/run_rust.py` (2 hunks)\\n* `.github/actions/generate-coverage/tests/test_scripts.py` (2 hunks)\\n\\n</details>\\n\\n<details>\\n<summary>🧰 Additional context used</summary>\\n\\n<details>\\n<summary>📓 Path-based instructions (1)</summary>\\n\\n<details>\\n<summary>.github/actions/*/tests/**</summary>\\n\\n\\n**📄 CodeRabbit Inference Engine (AGENTS.md)**\\n\\n> `.github/actions/*/tests/**`: Tests for each action must be present in a `tests/` directory within the action's directory.\\n> Contract tests must validate that declared inputs and outputs round-trip correctly.\\n\\nFiles:\\n- `.github/actions/generate-coverage/tests/test_scripts.py`\\n\\n</details>\\n\\n</details><details>\\n<summary>🧬 Code Graph Analysis (1)</summary>\\n\\n<details>\\n<summary>.github/actions/generate-coverage/scripts/run_rust.py (1)</summary><blockquote>\\n\\n<details>\\n<summary>.github/actions/ratchet-coverage/scripts/run_coverage.py (1)</summary>\\n\\n* `extract_percent` (19-25)\\n\\n</details>\\n\\n</blockquote></details>\\n\\n</details>\\n\\n</details>\\n\\n<details>\\n<summary>🔇 Additional comments (3)</summary><blockquote>\\n\\n<details>\\n<summary>.github/actions/generate-coverage/scripts/run_rust.py (1)</summary>\\n\\n`90-90`: **Excellent conditional logic for format-specific parsing.**\\n\\nThe modification correctly routes LCOV format processing to the new function while preserving existing behaviour for other formats. This maintains backward compatibility and leverages the structured nature of LCOV files for more reliable parsing.\\n\\n</details>\\n<details>\\n<summary>.github/actions/generate-coverage/tests/test_scripts.py (2)</summary>\\n\\n`26-26`: **Correct LCOV test data format.**\\n\\nThe test data correctly simulates LCOV format output with appropriate LF (lines found) and LH (lines hit) entries. The values 200 and 163 produce a clean 81.50% calculation for verification.\\n\\n---\\n\\n`64-64`: **Correct assertion update for new formatting.**\\n\\nThe assertion properly reflects the new 2-decimal place formatting introduced by `percent_from_lcov`. The expected value \\\"81.50\\\" correctly matches the calculation from the test data (163/200 * 100).\\n\\n</details>\\n\\n</blockquote></details>\\n\\n</details>\\n\\n<!-- This is an auto-generated comment by CodeRabbit for review status -->\",\"state\":\"CHANGES_REQUESTED\",\"submittedAt\":\"2025-07-27T02:14:20Z\",\"author\":{\"login\":\"coderabbitai\"}},{\"body\":\"\",\"state\":\"COMMENTED\",\"submittedAt\":\"2025-07-27T12:07:00Z\",\"author\":{\"login\":\"leynos\"}},{\"body\":\"\",\"state\":\"COMMENTED\",\"submittedAt\":\"2025-07-27T12:07:06Z\",\"author\":{\"login\":\"leynos\"}},{\"body\":\"\",\"state\":\"COMMENTED\",\"submittedAt\":\"2025-07-27T12:07:31Z\",\"author\":{\"login\":\"sourcery-ai\"}},{\"body\":\"**Actionable comments posted: 1**\\n\\n<details>\\n<summary>♻️ Duplicate comments (3)</summary><blockquote>\\n\\n<details>\\n<summary>.github/actions/generate-coverage/tests/test_scripts.py (3)</summary><blockquote>\\n\\n`160-167`: **Approve edge case testing for zero lines found.**\\n\\nThis test correctly addresses the past review feedback by testing the zero-division edge case where no lines are found in the LCOV file.\\n\\n---\\n\\n`169-174`: **Approve testing for missing LH tag scenario.**\\n\\nThis test correctly addresses the past review feedback by testing the edge case where the LH tag is missing from the LCOV file, ensuring graceful handling.\\n\\n---\\n\\n`176-181`: **Approve malformed file testing but verify error handling.**\\n\\nThis test correctly addresses the past review feedback by testing malformed LCOV files. However, verify that the current implementation handles mixed numeric/non-numeric values gracefully, as `map(int, ...)` could raise `ValueError` for partially malformed files.\\n\\n\\n\\n\\n\\nRun this script to verify error handling behaviour:\\n\\n```shell\\n#!/bin/bash\\n# Description: Test how the function handles mixed numeric/non-numeric LCOV values\\n\\ncd .github/actions/generate-coverage\\n\\npython3 -c \\\"\\nfrom pathlib import Path\\nimport tempfile\\nimport sys\\nsys.path.insert(0, 'scripts')\\nfrom run_rust import get_line_coverage_percent_from_lcov\\n\\nwith tempfile.NamedTemporaryFile(mode='w', suffix='.lcov', delete=False) as f:\\n    f.write('LF:100\\\\nLH:abc\\\\n')  # Mixed valid/invalid\\n    f.flush()\\n    \\n    try:\\n        result = get_line_coverage_percent_from_lcov(Path(f.name))\\n        print(f'Result: {result}')\\n    except Exception as e:\\n        print(f'Exception: {type(e).__name__}: {e}')\\n\\\"\\n```\\n\\n</blockquote></details>\\n\\n</blockquote></details>\\n\\n<details>\\n<summary>📜 Review details</summary>\\n\\n**Configuration used: CodeRabbit UI**\\n**Review profile: ASSERTIVE**\\n**Plan: Pro**\\n\\n\\n<details>\\n<summary>📥 Commits</summary>\\n\\nReviewing files that changed from the base of the PR and between df83e64b7de0331d42340b00431439d6bab7426a and f81fcbc70f5898943db749ecadda22c51d98c756.\\n\\n</details>\\n\\n<details>\\n<summary>📒 Files selected for processing (2)</summary>\\n\\n* `.github/actions/generate-coverage/scripts/run_rust.py` (2 hunks)\\n* `.github/actions/generate-coverage/tests/test_scripts.py` (4 hunks)\\n\\n</details>\\n\\n<details>\\n<summary>🧰 Additional context used</summary>\\n\\n<details>\\n<summary>📓 Path-based instructions (1)</summary>\\n\\n<details>\\n<summary>.github/actions/*/tests/**</summary>\\n\\n\\n**📄 CodeRabbit Inference Engine (AGENTS.md)**\\n\\n> `.github/actions/*/tests/**`: Tests for each action must be present in a `tests/` directory within the action's directory.\\n> Contract tests must validate that declared inputs and outputs round-trip correctly.\\n\\nFiles:\\n- `.github/actions/generate-coverage/tests/test_scripts.py`\\n\\n</details>\\n\\n</details>\\n\\n</details>\\n\\n<details>\\n<summary>🔇 Additional comments (3)</summary><blockquote>\\n\\n<details>\\n<summary>.github/actions/generate-coverage/scripts/run_rust.py (1)</summary>\\n\\n`101-105`: **LGTM! Clean conditional logic for format-specific parsing.**\\n\\nThe conditional logic correctly branches between LCOV file parsing and stdout parsing based on the format parameter whilst maintaining backward compatibility.\\n\\n</details>\\n<details>\\n<summary>.github/actions/generate-coverage/tests/test_scripts.py (2)</summary>\\n\\n`26-57`: **Excellent test fixture for isolated module testing.**\\n\\nThe fixture correctly implements dynamic module loading with stubbed dependencies, enabling isolated testing of internal functions without external dependencies. The approach of using importlib and monkeypatch is well-executed.\\n\\n---\\n\\n`64-64`: **Approve test updates for LCOV format consistency.**\\n\\nThe test correctly pre-populates the coverage file with LCOV format data and asserts the percentage with two decimal places, matching the new parsing function's output format.\\n\\n\\n\\n\\nAlso applies to: 102-102\\n\\n</details>\\n\\n</blockquote></details>\\n\\n</details>\\n\\n<!-- This is an auto-generated comment by CodeRabbit for review status -->\",\"state\":\"CHANGES_REQUESTED\",\"submittedAt\":\"2025-07-27T12:15:53Z\",\"author\":{\"login\":\"coderabbitai\"}},{\"body\":\"**Actionable comments posted: 3**\\n\\n<details>\\n<summary>♻️ Duplicate comments (1)</summary><blockquote>\\n\\n<details>\\n<summary>.github/actions/generate-coverage/scripts/run_rust.py (1)</summary><blockquote>\\n\\n`51-73`: **Add error handling for file operations and malformed content.**\\n\\nThe function lacks error handling for file reading failures and malformed content. Add try-except blocks to handle potential exceptions gracefully.\\n\\n\\n\\n\\n```diff\\n def get_line_coverage_percent_from_lcov(lcov_file: Path) -> str:\\n     \\\"\\\"\\\"Return the overall line coverage percentage from an ``lcov.info`` file.\\n\\n     Parameters\\n     ----------\\n     lcov_file : Path\\n         Path to the coverage file to read.\\n\\n     Returns\\n     -------\\n     str\\n         The coverage percentage with two decimal places.\\n     \\\"\\\"\\\"\\n-    text = lcov_file.read_text(encoding=\\\"utf-8\\\")\\n+    try:\\n+        text = lcov_file.read_text(encoding=\\\"utf-8\\\")\\n+    except (FileNotFoundError, PermissionError, UnicodeDecodeError) as exc:\\n+        typer.echo(f\\\"Could not read LCOV file {lcov_file}: {exc}\\\", err=True)\\n+        raise typer.Exit(code=1) from exc\\n\\n     def total(tag: str) -> int:\\n-        return sum(map(int, re.findall(rf\\\"^{tag}:(\\\\d+)$\\\", text, flags=re.MULTILINE)))\\n+        try:\\n+            return sum(map(int, re.findall(rf\\\"^{tag}:(\\\\d+)$\\\", text, flags=re.MULTILINE)))\\n+        except ValueError as exc:\\n+            typer.echo(f\\\"Malformed LCOV file {lcov_file}: invalid {tag} values\\\", err=True)\\n+            raise typer.Exit(code=1) from exc\\n\\n     lines_found = total(\\\"LF\\\")\\n     lines_hit = total(\\\"LH\\\")\\n     if lines_found == 0:\\n         return \\\"0.00\\\"\\n     return f\\\"{lines_hit / lines_found * 100:.2f}\\\"\\n```\\n\\n</blockquote></details>\\n\\n</blockquote></details>\\n\\n<details>\\n<summary>📜 Review details</summary>\\n\\n**Configuration used: CodeRabbit UI**\\n**Review profile: ASSERTIVE**\\n**Plan: Pro**\\n\\n\\n<details>\\n<summary>📥 Commits</summary>\\n\\nReviewing files that changed from the base of the PR and between f81fcbc70f5898943db749ecadda22c51d98c756 and 531bca2744f3c96ffb67fb8b251294fd28f0ae78.\\n\\n</details>\\n\\n<details>\\n<summary>📒 Files selected for processing (3)</summary>\\n\\n* `.github/actions/generate-coverage/scripts/run_python.py` (3 hunks)\\n* `.github/actions/generate-coverage/scripts/run_rust.py` (3 hunks)\\n* `.github/actions/generate-coverage/tests/test_scripts.py` (4 hunks)\\n\\n</details>\\n\\n<details>\\n<summary>🧰 Additional context used</summary>\\n\\n<details>\\n<summary>📓 Path-based instructions (1)</summary>\\n\\n<details>\\n<summary>.github/actions/*/tests/**</summary>\\n\\n\\n**📄 CodeRabbit Inference Engine (AGENTS.md)**\\n\\n> `.github/actions/*/tests/**`: Tests for each action must be present in a `tests/` directory within the action's directory.\\n> Contract tests must validate that declared inputs and outputs round-trip correctly.\\n\\nFiles:\\n- `.github/actions/generate-coverage/tests/test_scripts.py`\\n\\n</details>\\n\\n</details><details>\\n<summary>🧬 Code Graph Analysis (3)</summary>\\n\\n<details>\\n<summary>.github/actions/generate-coverage/scripts/run_rust.py (2)</summary><blockquote>\\n\\n<details>\\n<summary>.github/actions/generate-coverage/scripts/run_python.py (3)</summary>\\n\\n* `get_line_coverage_percent_from_cobertura` (46-85)\\n* `num_or_zero` (65-67)\\n* `lines_from_detail` (69-72)\\n\\n</details>\\n<details>\\n<summary>.github/actions/ratchet-coverage/scripts/run_coverage.py (1)</summary>\\n\\n* `extract_percent` (19-25)\\n\\n</details>\\n\\n</blockquote></details>\\n<details>\\n<summary>.github/actions/generate-coverage/scripts/run_python.py (1)</summary><blockquote>\\n\\n<details>\\n<summary>.github/actions/generate-coverage/scripts/run_rust.py (4)</summary>\\n\\n* `get_line_coverage_percent_from_cobertura` (76-115)\\n* `num_or_zero` (95-97)\\n* `lines_from_detail` (99-102)\\n* `total` (66-67)\\n\\n</details>\\n\\n</blockquote></details>\\n<details>\\n<summary>.github/actions/generate-coverage/tests/test_scripts.py (4)</summary><blockquote>\\n\\n<details>\\n<summary>.github/actions/generate-coverage/tests/conftest.py (1)</summary>\\n\\n* `shell_stubs` (29-40)\\n\\n</details>\\n<details>\\n<summary>shellstub.py (1)</summary>\\n\\n* `StubManager` (39-153)\\n\\n</details>\\n<details>\\n<summary>.github/actions/generate-coverage/scripts/run_rust.py (2)</summary>\\n\\n* `get_line_coverage_percent_from_lcov` (51-73)\\n* `get_line_coverage_percent_from_cobertura` (76-115)\\n\\n</details>\\n<details>\\n<summary>.github/actions/generate-coverage/scripts/run_python.py (1)</summary>\\n\\n* `get_line_coverage_percent_from_cobertura` (46-85)\\n\\n</details>\\n\\n</blockquote></details>\\n\\n</details>\\n\\n</details>\\n\\n<details>\\n<summary>🔇 Additional comments (6)</summary><blockquote>\\n\\n<details>\\n<summary>.github/actions/generate-coverage/scripts/run_rust.py (2)</summary>\\n\\n`4-4`: **LGTM!**\\n\\nThe addition of `lxml` dependency is necessary for the new XML parsing functionality.\\n\\n---\\n\\n`143-149`: **LGTM!**\\n\\nThe conditional logic correctly selects the appropriate parser based on the format while maintaining backward compatibility.\\n\\n</details>\\n<details>\\n<summary>.github/actions/generate-coverage/scripts/run_python.py (1)</summary>\\n\\n`126-126`: **LGTM!**\\n\\nThe updates correctly use the new Cobertura parser for both coverage formats.\\n\\n\\n\\nAlso applies to: 129-129\\n\\n</details>\\n<details>\\n<summary>.github/actions/generate-coverage/tests/test_scripts.py (3)</summary>\\n\\n`26-57`: **LGTM!**\\n\\nThe fixtures provide excellent isolation for testing internal functions without external dependencies. The monkeypatching approach is well-implemented.\\n\\n\\n\\nAlso applies to: 183-216\\n\\n---\\n\\n`64-64`: **LGTM!**\\n\\nThe test correctly validates the new LCOV parsing logic with proper file content and two-decimal precision formatting.\\n\\n\\n\\nAlso applies to: 102-102\\n\\n---\\n\\n`218-260`: **LGTM!**\\n\\nThe Cobertura tests comprehensively cover the parsing logic including detail extraction, fallback to root totals, and edge cases.\\n\\n</details>\\n\\n</blockquote></details>\\n\\n</details>\\n\\n<!-- This is an auto-generated comment by CodeRabbit for review status -->\",\"state\":\"CHANGES_REQUESTED\",\"submittedAt\":\"2025-07-27T12:53:18Z\",\"author\":{\"login\":\"coderabbitai\"}}],\"pageInfo\":{\"hasNextPage\":false,\"endCursor\":\"Y3Vyc29yOnYyOpO5MjAyNS0wNy0yN1QxMzo1MzoxOCswMTowMLkyMDI1LTA3LTI3VDEzOjUzOjE3KzAxOjAwzrZcoFA=\"}}}}}}"}
